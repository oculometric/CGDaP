pathfinding needs to discretise spaces in order to use algorithms to navigate them. we save a lot of time by precomputing the size of our agents and baking that into their navmesh.

navigation errors commonly happen when the navmesh is incorrect and has left out some level geometry (i.e. navmesh says there is a path through when there isnt). keeping traversible areas updated is very hard when objects are dynamic.

simple 2d grids aren't enough for navmesh generation, diagonal or narrow corridors may be completely missed, areas may end up completely disconnected, and the shape of any non-square space won't be accurately represented.

can be generated by randomly circle-filling the space. circles grow until they hit level geometry, and become neighbours if they hit one another.

waypoints can be placed throughout the scene, and joined according to line-of-sight between each pair of points. agents hug line of sight.

navmeshes are usually generated by voxelising the scene mesh to a heightfield, which is then segmented to define a walkable area, then simplified with triangulation. each voxel is tagged walkable or not based on whether the span around it meets the requirements of the agent (height + width). need to check the step height of voxels in order to determine if they're walkable.

distance fields are generated based on their distance to the nearest border. generated from a heightmap using watershed algorithm. pixel lightness 'flows' off higher pixels into nearby basins.

when cleaning up navmeshes, smooth the edges of areas, triangulate with delaunay. then build a cell and portal graph, which is what we actually pathfind over.

greedy path smoothing - for each node, raycast from the previous to the next, if successful then the intermediate node can be culled.

string pulled path - raycast from first node to each. if line-of-sight, skip to next. once we hit geometry, create a new vertex with the lowest angle deviation from the unsmoothed path. rinse and repeat until we reach the end of the path.

navmesh path generation uses the funnel algorithm for smoothing paths.
https://gamedev.stackexchange.com/questions/68302/how-does-the-simple-stupid-funnel-algorithm-work
