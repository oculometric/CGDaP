a) in OpenGL 1.x, point lights are lights which are evaluated similar to a lamp, where lighting calculations take into account the distance from the light to the surface, the falloff characteristics of the light source, the directionality (exponent) of the light source, and the angle of the light source (a small angle behaves like a torchlight, while 180 degrees behaves like a star emitting light in all directions). a directional light instead simulates light coming from very far away, such as from the sun; lighting calculations only take into account the angle between the surface normal and the light direction. directional lights have no falloff with distance and all rays are treated as travelling parallel to the direction specified.

b) ambient, diffuse, and specular light are components in the Blinn lighting model used to produce somewhat-realistic looking lighting. ambient light is light which simply exists in the scene, as if coming from all directions at once. diffuse light is light which comes from a direction and illuminates a surface dependent on the angle between the direction of the light rays and the surface normal (as well as the distance to the light source, see answer above), such that light which is more tangential to the surface has less of a contribution to brightness. specular light simulates the effect of a shiny spot on a surface caused by direct reflection of the light source to the viewer, and depends on the angle between the viewer and the surface normal (at the fragment being evaluated) as well as the angle between the light rays and the surface normal. each of these three properties can be specified as coloured components of both lights and materials. when the colour of a fragment is being calculated, the following process is performed for each light: the ambient colour of the light is multiplied by the ambient colour of the material; the diffuse colour of the light is multiplied by the diffuse colour of the material and the dot product of the light direction and the surface normal (and optionally other factors for point lights); the specular colour of the light is multiplied by the specular colour of the material, and by the dot product between the view vector and the vector representing the reflected ray of light in the surface normal (to the power of some exponent); and all of these colour contributions are then added together to produce the total contribution of any particular light. this process is then repeated for all other lights, and the results for each light are added together and the final total is the colour value assigned to the pixel.

d) ambient colour of the material would appear black (since black multiplied by any other colour is black, multiplying all components by 0). diffuse colour of the material would be red (since pure white multiplied by any other colour makes no change to the original colour, multiplying all components by 1). specular colour of the material would be black (as before). thus, the sphere would appear only as being diffusely red, which would appear brightest on the side of the sphere closest to and facing the light, tapering to black at the equator, and with the entire hemisphere facing away from the light being totally black.
by changing the material's diffuse colour to be pure green, we retain all the same properties as before except that the sphere now appears diffusely green instead of red, with the same pattern of lighting across the surface.

e) the fixed function pipeline means: all objects must be rendered with the same system of lighting (ambient, diffuse, specular, emission); secondary textures for things like bump/normal maps are not supported; complex effects like screen-space reflection and reflection are not possible; displacement is also not possible. programmable shaders solve this problem by giving the programmer the freedom to design custom programs which replace the default pipeline. this allows almost every stage of the pipeline to be altered to behave differently for different materials, allowing for all the above mentioned techniques, as well as novel shading methods, stylised rendering, complex GPU-accelerated post-processing, and specialised rendering like ray-tracing (although modern GPUs also have dedicated functionality for this), through writing custom pieces of code which are run on the GPU for each vertex and/or pixel.