For this module I completed two prototypes: first a shorter turn-based game, and second a longer procedural-generation centred exploration game. Throughout both, my time management, estimation, and working effectiveness improved. These projects also challenged me with both technical hurdles and architectural ones. I will discuss some of these points below.

In previous projects, I often find myself working late at night, and working in very unevenly distributed blocks. My commitment to a project might vary depending on the current task I'm working on, or more specifically how much direction I have for the task. I noticed this tendency reappearing with certain tasks I set myself during development, where the larger, less well-defined tasks became harder to motivate myself towards and felt more aimless. However, following the agile methodology for these prototypes lead me to minimise this effect: one key feature of the agile methodology is breaking the overall product down into individual, achievable modules, a practice called Feature Driven Development[^1] (Kumar and Bhatia, 2012). Following this technique definitely made me more productive, especially early on in my second prototype where I took on a complex procedural generation system for constructing a chunk-grid-based world. By breaking this down into several different parts (a basic framework, support for custom chunk patterns, support for flood-fill analysis, plants, details) I was able to maintain an idea of the whole without being overwhelmed by it and focussing on the specific parts being developed. This also encouraged me to consider the architecture of the procedural generation system, and how I could build it such that I could add new features to it later (something I did indeed do).

These prototypes pushed me to consider carefully how and when to use appropriate programming paradigms. Reading the book Game Programming Patterns[^2] (Nystrom, 2014) not only expanded the range of techniques I understand, but also made me reconsider the benefits of some that I was already aware of. For instance, Nystrom particularly questions over-use of the singleton paradigm: this lead me to minimise my use of this technique in my second prototype. I originally considered using singletons for each of the Map Generator, the World Controller, Player Controller, and the Game Controller, but after more consideration I eliminated the need for singletons on all but the Game Controller, which now acts primarily as a bridge to allow different controllers to interact without keeping numerous global references hanging around. I also found use for the flyweight pattern when designing the Map Generator: instead of keeping a list of every possible pattern for every tile, each tile keeps a list of indices, which index into a list of possible patterns, massively reducing data duplication during generation. I made limited use of inheritance for creating different types of hold-able and interact-able objects, being careful to balance minimisation of code reuse with unnecessary complexity of inheritance hierarchies. This made creating different kinds of objects for testing and gameplay easy.

Although my time estimation for tasks improved over the duration of the two prototypes, it still isn't perfect. Interestingly, a pattern which I noticed emerging was that during the early and late stages of both prototypes, my time estimations for how long tasks would take was reasonably accurate (although less so with the first prototype), often within 10 minutes of the real time. However, both projects suffered poorer accuracy during the middle period. Reflecting on the specific tasks, and how I felt when working on these middle-periods, I found myself feeling somewhat directionless at times. It appeals to common sense, and literature supports the idea that uncertainty or changes in the direction of a project will negatively impact the accuracy of time estimations (Popli and Chauhan, 2014).

Overall, I actually enjoyed working within the agile framework for these projects. I feel it made me more efficient, and less stressed, and as a result I'm proud of the two prototypes I produced. Particularly the second prototype, in which I'm particularly happy with the multiple procedural generation techniques I employed (wave function collapse, flood fill, void-and-cluster).

[^1]: Kumar, G. and Bhatia, P.K., 2012. Impact of agile methodology on software development process. _International Journal of Computer Technology and Electronics Engineering (IJCTEE)_, _2_(4), pp.46-50.
[^2]: Nystrom, R. (2014). _Game programming patterns_. United States? Genever Benning.
[^3]: Popli, R. and Chauhan, N. (2014). _Cost and effort estimation in agile software development_. IEEE Xplore. doi:https://doi.org/10.1109/ICROIT.2014.6798284.