- divide and conquer
	- solve two subproblems in parallel, and combine the answers afterward to solve the problem quicker
	- solving smaller problems is often easier to conceptualise than solving the entire problem in one go

- recursion
	- can be used to solve subproblems incrementally
	- recursion - when a function calls itself at some point. you usually need a break/base case, otherwise your function will recurse infinitely
	- lots of instances of recursion can be replaced with a loop. generally where you can, it's a good idea to replace recursion with loops
	- recursion allows us to define a smaller problem space
	- recursion tends to be more elegant, potentially easier to understand/maintain
	- big flex too
	- however, every step of depth of recursion adds a stack frame to the call stack. if you do this too far, you will end up with a stack overflow (run out of stack space)

- memoisation
	- an extension of recursion, a method of optimisation
	- the Fibonacci sequence requires you to calculate every number in the sequence before it if you want to find a particular number
	- you can represent this as a tree of requirements
	- this tree has duplicate requirements however
	- memoisation is a technique for reducing the amount of computation by storing the evaluated value of a subtree (e.g. a subtree of fib(6) might be fib(3), which is a subtree of fib(4) as well as fib(5)), so that we don't need to recompute the value whenever we reuse it
	- this involves just adding each calculated subtree to a dictionary (e.g. with a key for the index in the Fibonacci sequence and a value for the actual number at that index in the fib sequence)

- multithreading (aka parallel processing)
	- can be used to solve subproblems in parallel simultaneously
	- we have to assume that any parallel tasks do not rely on data from one another (otherwise we'd end up with one subtask waiting on another)
	- when all of the subtasks are done, they can be joined onto the main thread and their results collated to be used to solve the main task
	- e.g. solving multiple long maths problems in 4 separate threads, and then summing the results in the main thread again when they have all finished
	- requires careful management of resources so that your multiple threads cannot overwrite or corrupt shared data
	- race conditions may occur where one thread reaches data before another thread, where you were expecting the other thread to reach it first. you need to account for threads taking different amount of time and lock resources using checks and `std::mutex`es. **thread safety**
	- maintaining thread safety as well as maintaining efficiency is the key challenge of multithreading
	- having too many threads will lead to overloading the scheduler, leading to actually worse performance: if there's too many threads competing for time on the CPU, the time required to switch between them will eventually lead to slowdown. ideally your number of worker threads should equal the number of logical cores your computer has to maximise performance
	- don't ever use a foreach loop in Unreal
	- starting up threads also has overhead, so balancing for overhead vs parallelisation is important