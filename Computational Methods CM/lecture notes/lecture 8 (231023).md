- sorting involves putting elements already in a data structure in a particular order based on a rule or set of rules
- bubble sort:
	- traverse left to right
	- at each item if the left item (i.e. current) is greater than the right item (i.e. next) in a pair, swap them, otherwise do nothing
	- continue for each item
	- if we swapped some items in the last pass, go back to the start of the list, otherwise the list is sorted and we can stop
	- we can slightly optimise this by checking one fewer item each time (since we know we must have moved the greatest item all the way to the end each time)
	- O(n^2) time complexity, very slow for unsorted data
- insertion sort:
	- split the list
	- traverse the unsorted list
	- for each item, insert it into the correct place in the sorted list by traversing the sorted list
	- we keep track of which segment of the list is sorted and which is not
	- stop when the sorted segment takes up the entire list
	- O(n^2) time complexity
- selection sort:
	- find the smallest number in the unsorted list
	- put that at the end of the sorted list, remove it from the unsorted list (this can either be done as a separate list, or in the same list by swapping the new smallest item into the front of the list)
	- repeat this until there are no unsorted items left
	- O(n^2) time complexity
- merge sort:
	- splits the dataset in half repeatedly until the chunks cannot be made smaller
	- uses recursion
	- once the data has been split down to individual item lists, it can be merged incrementally up the stages again, and the final merge returns the fully sorted list
	- to merge two sublists:
		- compare the first items of each sublists
		- insert the smaller
		- increment the pointer on the list it was from
		- repeat until all are inserted into the merged list
	- O(nlog2(n)) time complexity
	- however, uses more memory than others as swaps are not done in place
	- can be split in order to multitask (divide and conquer)
- quick sort:
	- select a pivot
	- move elements greater than the pivot to the right, less than the pivot to the right
	- repeat with another pivot on each side
	- repeat until there is only one item on each side of the pivot
	- O(n^2), but Theta(nlog2(n)) on average
	- choices with pivots matter a lot with quick sort
	- its often good to randomize the list before you sort it
	- can be divide-and-conquered
	- can be done in place without juggling
- lots more, Introsort, Timsort, etc 